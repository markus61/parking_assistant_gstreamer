# -*- coding: utf-8 -*-
"""projective_transform

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z_gBLaNOzpgvCkXWAUNcrujhLhR2j47H
"""
import numpy as np
from configparser import ConfigParser
import warnings

class Homography2():
    """_summary_
    internal values are hidden eg. self.__width_src
    internal angles are in radiant
    setters for angles accept degrees

    The full rotation matrix is the product of three individual rotation matrices, but the order of multiplication is important. 
    For example, a common convention is to multiply them in ZYX order (roll * pitch * yaw)
    """

    def __init__(self, camera_config:str = ""):
        self.__roll = 0.0
        self.__pitch = 0.0
        self.__yaw = 0.0
        self.__x_matrix = np.identity(3, dtype=np.float32)
        self.__y_matrix = np.identity(3, dtype=np.float32)
        self.__z_matrix = np.identity(3, dtype=np.float32)
        self.__camera_x = 0.0                                                # camera center X position in world coordinates (mm)
        self.__camera_y = 0.0                                                # camera center Y position in world coordinates (mm)
        self.__camera_z = 0.0                                                # camera center Z position in world coordinates (mm)

        parser = ConfigParser()
        parser.read('./config/camera.ini')
        cam_section = parser[camera_config] if camera_config in parser else {}
        self.__pixel_size = float(cam_section.get('pixel_size', '0.00145'))  # mm per pixel
        self.__efl = float(cam_section.get('efl', '2.95'))                  # effective focal length in mm
        self.__cam_width = int(cam_section.get('width', '1280'))
        self.__cam_height = int(cam_section.get('height', '720'))
    
    @property
    def translation(self):
        """
        Compute translation vector t in camera coordinates.

        In the pinhole camera model P = K[R|t], the translation t relates to
        the camera center C (in world coords) by: t = -R¬∑C

        This ensures correct metric rectification where the pixel-to-meter scale
        depends on actual perpendicular distance from camera to the world plane.

        Returns:
            3x1 numpy array: translation vector in camera coordinates (mm)
        """
        camera_center = np.array([[self.camera_x], [self.camera_y], [self.camera_z]], dtype=np.float32)
        return -self.R @ camera_center

    @property
    def camera_x(self):
        return self.__camera_x

    @camera_x.setter
    def camera_x(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_x must be numeric, got {type(value).__name__}")
        self.__camera_x = value

    @property
    def camera_y(self):
        return self.__camera_y

    @camera_y.setter
    def camera_y(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_y must be numeric, got {type(value).__name__}")
        self.__camera_y = value

    @property
    def camera_z(self):
        return self.__camera_z

    @camera_z.setter
    def camera_z(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_z must be numeric, got {type(value).__name__}")
        self.__camera_z = value

    @property
    def cam_width(self):
        return self.__cam_width

    @cam_width.setter
    def cam_width(self, value):
        # Validate input is integer
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError(f"cam_width must be numeric, got {type(value).__name__}")

        # Validate positive
        if value <= 0:
            raise ValueError(f"cam_width must be positive, got {value}")

        # Warn if unrealistic
        if value < 100 or value > 10000:
            warnings.warn(f"cam_width {value} seems unrealistic (typical range: 100-10000)")

        self.__cam_width = value

    @property
    def cam_height(self):
        return self.__cam_height

    @cam_height.setter
    def cam_height(self, value):
        # Validate input is integer
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError(f"cam_height must be numeric, got {type(value).__name__}")

        # Validate positive
        if value <= 0:
            raise ValueError(f"cam_height must be positive, got {value}")

        # Warn if unrealistic
        if value < 100 or value > 10000:
            warnings.warn(f"cam_height {value} seems unrealistic (typical range: 100-10000)")

        self.__cam_height = value

    @property
    def invert(self):
        Hi = np.linalg.inv(self.H)
        return Hi
            
    @property
    def roll(self):
        return np.rad2deg(self.__roll)

    @roll.setter
    def roll(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"roll angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"roll angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__roll = np.radians(value)
        self.__x_matrix = np.array([
            [1,             0,              0],
            [0,  np.cos(self.__roll), -np.sin(self.__roll)],
            [0,  np.sin(self.__roll),  np.cos(self.__roll)]
        ], dtype=np.float32)

    @property
    def pitch(self):
        return np.rad2deg(self.__pitch)

    @pitch.setter
    def pitch(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"pitch angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"pitch angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__pitch = np.radians(value)
        self.__y_matrix = np.array([
            [ np.cos(self.__pitch),  0, np.sin(self.__pitch)],
            [ 0,              1,        0],
            [-np.sin(self.__pitch),  0, np.cos(self.__pitch)]
        ], dtype=np.float32)

    @property
    def yaw(self):
        return np.rad2deg(self.__yaw)

    @yaw.setter
    def yaw(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"yaw angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"yaw angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__yaw = np.radians(value)
        self.__z_matrix = np.array([
            [ np.cos(self.__yaw), -np.sin(self.__yaw), 0],
            [ np.sin(self.__yaw),  np.cos(self.__yaw), 0],
            [ 0,             0,            1]
        ], dtype=np.float32)

    @property
    def R(self):
        R = self.__z_matrix @ self.__y_matrix @ self.__x_matrix
        return R

    @property
    def K(self):
        """Intrinsic camera matrix K"""
        fx = self.__efl / self.__pixel_size
        fy = self.__efl / self.__pixel_size
        cx = self.cam_width / 2.0
        cy = self.cam_height / 2.0
        K = np.array([
            [ fx,   0.0,   cx],
            [ 0.0,   fy,   cy],
            [ 0.0,  0.0,  1.0]
        ], dtype=np.float32)
        return K
    
    @property 
    def H(self):
        return self.K @ np.column_stack([self.R[:,[0,1]], self.translation])

    @property
    def normalized(self):
        """
        Return normalized homography matrix (divided by bottom-right element).
        In homogeneous coordinates, matrices are equivalent up to scalar multiplication.
        Normalization ensures the [2,2] element is 1.0 for consistency.
        """
        # --- normalize ---
        matrix = np.copy(self.H)
        matrix /= matrix[2, 2]   # ensures bottom-right = 1 (usually redundant, but safe)
        return matrix

    def __repr__(self) -> str:
        """Cute representation showing the transformation state and matrices."""
        angles = f"üìê roll={self.roll:.1f}¬∞ tilt={self.pitch:.1f}¬∞ yaw={self.yaw:.1f}¬∞"

        # Pretty print the regular matrix with aligned columns
        matrix = self.H
        matrix_lines = []
        for row in matrix:
            formatted_row = "  ‚îÇ" + "  ".join(f"{val:7.3f}" for val in row) + "‚îÇ"
            matrix_lines.append(formatted_row)

        matrix_str = "\n".join([
            "  Matrix:",
            "  ‚îå" + " " * 25 + "‚îê",
            matrix_lines[0],
            matrix_lines[1],
            matrix_lines[2],
            "  ‚îî" + " " * 25 + "‚îò"
        ])

        # Pretty print the normalized matrix
        matrix_norm = self.normalized
        matrix_norm_lines = []
        for row in matrix_norm:
            formatted_row = "  ‚îÇ" + "  ".join(f"{val:7.4f}" for val in row) + "‚îÇ"
            matrix_norm_lines.append(formatted_row)

        matrix_norm_str = "\n".join([
            "  Matrix (normalized):",
            "  ‚îå" + " " * 25 + "‚îê",
            matrix_norm_lines[0],
            matrix_norm_lines[1],
            matrix_norm_lines[2],
            "  ‚îî" + " " * 25 + "‚îò"
        ])

        return (
            f"Homography2(\n"
            f"  {angles}\n"
            f"{matrix_str}\n"
            f"{matrix_norm_str}\n"
            f")"
        )
