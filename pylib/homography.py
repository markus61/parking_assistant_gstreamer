# -*- coding: utf-8 -*-
"""projective_transform

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z_gBLaNOzpgvCkXWAUNcrujhLhR2j47H
"""
import numpy as np
from configparser import ConfigParser
import warnings

class Homography2():
    """
    Compute homography for plane-to-image perspective transformations with metric rectification.

    Supports two primary scenarios:
    1. **Development**: Wall-mounted cameras looking at vertical wall (fronto-parallel)
    2. **Production**: Mast-mounted cameras looking downward at water surface

    The homography maps 2D world coordinates on a planar surface to 2D image coordinates,
    enabling metric rectification where 1 meter equals the same number of pixels everywhere
    in the rectified image (within <10% variation).

    PLANE MODEL:
    - plane_normal: Unit normal vector in world coordinates (default: [0,0,1] for Z=0 plane)
    - plane_distance: Signed distance from origin to plane in mm (default: None = auto-compute)

    CAMERA MODEL:
    - camera_x, camera_y, camera_z: Camera center position in world coordinates (mm)
    - roll, pitch, yaw: Camera orientation angles in degrees (ZYX Euler order)
    - K: Intrinsic matrix computed from focal length, pixel size, and resolution

    HOMOGRAPHY FORMULA:
    Currently uses simplified formula H = K[r1 r2 t] assuming Z=0 plane.
    Future enhancement: H = K¬∑(R - t¬∑n·µÄ/d)¬∑K_w‚Åª¬π for arbitrary planes.

    INTERNAL REPRESENTATION:
    - Internal angles stored in radians (setters accept degrees)
    - Internal properties prefixed with __ (double underscore)
    - Rotation matrix computed as R = Rz(yaw) @ Ry(pitch) @ Rx(roll) [ZYX order]

    USAGE:
        # Development setup (wall-mounted camera)
        h = Homography2("radxa4K")
        h.configure_for_wall(distance_mm=4000.0)
        h.camera_x = -50.0  # Left camera
        h.yaw = 37.5  # Pan outward

        # Production setup (mast camera)
        h = Homography2("radxa4K")
        h.configure_for_water_surface(height_above_water_mm=12000.0)
        h.camera_x = -750.0
        h.yaw = 37.5
        h.pitch = -60.0
        h.roll = 90.0
    """

    def __init__(self, camera_config:str = ""):
        self.__roll = 0.0
        self.__pitch = 0.0
        self.__yaw = 0.0
        self.__x_matrix = np.identity(3, dtype=np.float32)
        self.__y_matrix = np.identity(3, dtype=np.float32)
        self.__z_matrix = np.identity(3, dtype=np.float32)
        self.__camera_x = 0.0                                                # camera center X position in world coordinates (mm)
        self.__camera_y = 0.0                                                # camera center Y position in world coordinates (mm)
        self.__camera_z = 0.0                                                # camera center Z position in world coordinates (mm)

        # Plane model parameters (world coordinates)
        self.__plane_normal = np.array([[0.0], [0.0], [1.0]], dtype=np.float32)  # Default: Z=0 plane
        self.__plane_distance = None                                         # None = auto-compute from camera_z (backward compatible)

        parser = ConfigParser()
        parser.read('./config/camera.ini')
        cam_section = parser[camera_config] if camera_config in parser else {}
        self.__pixel_size = float(cam_section.get('pixel_size', '0.00145'))  # mm per pixel
        self.__efl = float(cam_section.get('efl', '2.95'))                  # effective focal length in mm
        self.__cam_width = int(cam_section.get('width', '1280'))
        self.__cam_height = int(cam_section.get('height', '720'))
    
    @property
    def translation(self):
        """
        Compute translation vector t in camera coordinates.

        In the pinhole camera model P = K[R|t], the translation t relates to
        the camera center C (in world coords) by: t = -R¬∑C

        This ensures correct metric rectification where the pixel-to-meter scale
        depends on actual perpendicular distance from camera to the world plane.

        Returns:
            3x1 numpy array: translation vector in camera coordinates (mm)
        """
        camera_center = np.array([[self.camera_x], [self.camera_y], [self.camera_z]], dtype=np.float32)
        return -self.R @ camera_center

    @property
    def camera_x(self):
        return self.__camera_x

    @camera_x.setter
    def camera_x(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_x must be numeric, got {type(value).__name__}")
        self.__camera_x = value

    @property
    def camera_y(self):
        return self.__camera_y

    @camera_y.setter
    def camera_y(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_y must be numeric, got {type(value).__name__}")
        self.__camera_y = value

    @property
    def camera_z(self):
        return self.__camera_z

    @camera_z.setter
    def camera_z(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"camera_z must be numeric, got {type(value).__name__}")
        self.__camera_z = value

    @property
    def cam_width(self):
        return self.__cam_width

    @cam_width.setter
    def cam_width(self, value):
        # Validate input is integer
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError(f"cam_width must be numeric, got {type(value).__name__}")

        # Validate positive
        if value <= 0:
            raise ValueError(f"cam_width must be positive, got {value}")

        # Warn if unrealistic
        if value < 100 or value > 10000:
            warnings.warn(f"cam_width {value} seems unrealistic (typical range: 100-10000)")

        self.__cam_width = value

    @property
    def cam_height(self):
        return self.__cam_height

    @cam_height.setter
    def cam_height(self, value):
        # Validate input is integer
        try:
            value = int(value)
        except (TypeError, ValueError):
            raise ValueError(f"cam_height must be numeric, got {type(value).__name__}")

        # Validate positive
        if value <= 0:
            raise ValueError(f"cam_height must be positive, got {value}")

        # Warn if unrealistic
        if value < 100 or value > 10000:
            warnings.warn(f"cam_height {value} seems unrealistic (typical range: 100-10000)")

        self.__cam_height = value

    @property
    def plane_normal(self):
        """
        Plane normal vector in world coordinates.

        The plane normal defines the orientation of the target plane for metric
        rectification. Default is [0,0,1] for Z=0 horizontal plane.

        Returns:
            3x1 numpy array: unit normal vector pointing from plane toward camera
        """
        return self.__plane_normal.copy()

    @plane_normal.setter
    def plane_normal(self, value):
        """
        Set plane normal vector in world coordinates.

        Args:
            value: Array-like [nx, ny, nz] or 3x1 array

        Raises:
            ValueError: If not 3D vector or zero length
        """
        try:
            n = np.array(value, dtype=np.float32).flatten()
        except (TypeError, ValueError):
            raise ValueError(f"plane_normal must be array-like, got {type(value).__name__}")

        if n.shape[0] != 3:
            raise ValueError(f"plane_normal must have 3 elements, got {n.shape[0]}")

        norm = np.linalg.norm(n)
        if norm < 1e-8:
            raise ValueError("plane_normal cannot be zero vector")

        # Normalize to unit vector and store as column vector
        self.__plane_normal = (n / norm).reshape(3, 1)

    @property
    def plane_distance(self):
        """
        Signed perpendicular distance from world origin to plane (mm).

        Positive when origin is on the side the normal points away from.
        None means auto-compute from camera_z (backward compatible).

        Returns:
            float or None: distance in millimeters
        """
        return self.__plane_distance

    @plane_distance.setter
    def plane_distance(self, value):
        """
        Set signed perpendicular distance from world origin to plane.

        Args:
            value: Distance in millimeters (can be negative, or None for auto-compute)

        Raises:
            ValueError: If not numeric or too close to zero (causes singularity)
        """
        if value is None:
            self.__plane_distance = None
            return

        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"plane_distance must be numeric or None, got {type(value).__name__}")

        # Warn if very small (could cause numerical instability)
        if abs(value) < 0.1:
            warnings.warn(f"plane_distance {value}mm is very small, may cause numerical instability")

        self.__plane_distance = value

    @property
    def invert(self):
        Hi = np.linalg.inv(self.H)
        return Hi
            
    @property
    def roll(self):
        return np.rad2deg(self.__roll)

    @roll.setter
    def roll(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"roll angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"roll angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__roll = np.radians(value)
        self.__x_matrix = np.array([
            [1,             0,              0],
            [0,  np.cos(self.__roll), -np.sin(self.__roll)],
            [0,  np.sin(self.__roll),  np.cos(self.__roll)]
        ], dtype=np.float32)

    @property
    def pitch(self):
        return np.rad2deg(self.__pitch)

    @pitch.setter
    def pitch(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"pitch angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"pitch angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__pitch = np.radians(value)
        self.__y_matrix = np.array([
            [ np.cos(self.__pitch),  0, np.sin(self.__pitch)],
            [ 0,              1,        0],
            [-np.sin(self.__pitch),  0, np.cos(self.__pitch)]
        ], dtype=np.float32)

    @property
    def yaw(self):
        return np.rad2deg(self.__yaw)

    @yaw.setter
    def yaw(self, value):
        # Validate input is numeric
        try:
            value = float(value)
        except (TypeError, ValueError):
            raise ValueError(f"yaw angle must be numeric, got {type(value).__name__}")

        # Warn if outside practical range
        if value < -180.0 or value > 180.0:
            warnings.warn(f"yaw angle {value}¬∞ is outside typical range [-180¬∞, 180¬∞]")

        self.__yaw = np.radians(value)
        self.__z_matrix = np.array([
            [ np.cos(self.__yaw), -np.sin(self.__yaw), 0],
            [ np.sin(self.__yaw),  np.cos(self.__yaw), 0],
            [ 0,             0,            1]
        ], dtype=np.float32)

    @property
    def R(self):
        R = self.__z_matrix @ self.__y_matrix @ self.__x_matrix
        return R

    @property
    def K(self):
        """Intrinsic camera matrix K"""
        fx = self.__efl / self.__pixel_size
        fy = self.__efl / self.__pixel_size
        cx = self.cam_width / 2.0
        cy = self.cam_height / 2.0
        K = np.array([
            [ fx,   0.0,   cx],
            [ 0.0,   fy,   cy],
            [ 0.0,  0.0,  1.0]
        ], dtype=np.float32)
        return K
    
    @property
    def H(self):
        """
        Compute homography matrix for plane-to-image transformation.

        CURRENT IMPLEMENTATION (backward compatible):
        Uses simplified formula: H = K[r1 r2 t]
        This assumes the world plane is perpendicular to camera Z-axis.

        PLANE MODEL:
        - plane_normal: defines plane orientation in world coords (default: [0,0,1])
        - plane_distance: signed distance from origin to plane (default: None = auto)

        TODO: Implement general plane-induced homography formula:
        H = K ¬∑ (R - t¬∑n·µÄ/d) ¬∑ K_w‚Åª¬π
        when plane_distance is explicitly set (not None).

        Returns:
            3x3 numpy array: homography mapping world plane to image coordinates
        """
        # Current simplified formula (works for Z=0 plane assumption)
        return self.K @ np.column_stack([self.R[:,[0,1]], self.translation])

    @property
    def normalized(self):
        """
        Return normalized homography matrix (divided by bottom-right element).
        In homogeneous coordinates, matrices are equivalent up to scalar multiplication.
        Normalization ensures the [2,2] element is 1.0 for consistency.
        """
        # --- normalize ---
        matrix = np.copy(self.H)
        matrix /= matrix[2, 2]   # ensures bottom-right = 1 (usually redundant, but safe)
        return matrix

    def configure_for_wall(self, distance_mm: float):
        """
        Configure homography for wall-mounted camera looking at vertical wall.

        This is the typical development setup where cameras are mounted on a wall
        looking at a fronto-parallel vertical surface (e.g., opposite wall).

        Args:
            distance_mm: Distance from camera to wall in millimeters

        Example:
            h = Homography2("radxa4K")
            h.configure_for_wall(distance_mm=4000.0)  # 4m to wall
            h.camera_x = -50.0  # Left camera at -5cm
            h.yaw = 37.5  # Pan outward
        """
        self.camera_z = distance_mm
        self.plane_normal = [0.0, 0.0, 1.0]  # Wall perpendicular to Z-axis
        self.plane_distance = distance_mm

    def configure_for_water_surface(self, height_above_water_mm: float):
        """
        Configure homography for mast camera looking down at water surface.

        This is the production setup where cameras are mounted on the yacht mast
        looking downward at the water surface for docking assistance.

        Assumes world coordinate system with Z-axis pointing up and water at Z=0.
        User must also set appropriate pitch angle for downward viewing.

        Args:
            height_above_water_mm: Camera height above water in millimeters

        Example:
            h = Homography2("radxa4K")
            h.configure_for_water_surface(height_above_water_mm=12000.0)  # 12m mast
            h.camera_x = -750.0  # Left camera at -75cm
            h.yaw = 37.5  # Pan outward
            h.pitch = -60.0  # Look downward
            h.roll = 90.0  # Rotate camera
        """
        self.camera_z = -height_above_water_mm  # Negative because above plane
        self.plane_normal = [0.0, 0.0, 1.0]  # Water surface horizontal (Z=0)
        self.plane_distance = 0.0  # Water at world origin

    def validate_plane_geometry(self) -> tuple[bool, str]:
        """
        Validate that plane parameters are geometrically consistent.

        Checks:
        - Plane normal is unit vector
        - Plane distance is reasonable (not too small)
        - Camera is not on the plane (would cause singularity)

        Returns:
            (is_valid, message): Tuple of validation result and explanation

        Example:
            is_valid, msg = h.validate_plane_geometry()
            if not is_valid:
                print(f"Warning: {msg}")
        """
        # Check normal is unit vector
        norm = np.linalg.norm(self.__plane_normal)
        if abs(norm - 1.0) > 1e-6:
            return False, f"Plane normal not unit vector: ||n|| = {norm:.6f}"

        # Check distance is reasonable (if set explicitly)
        if self.__plane_distance is not None:
            if abs(self.__plane_distance) < 0.1:
                return False, f"Plane distance too small: {self.__plane_distance}mm"

        # Check camera is not on plane
        camera_center = np.array([[self.camera_x], [self.camera_y], [self.camera_z]], dtype=np.float32)
        # Distance from camera to plane: n¬∑C - d
        dist_camera_to_plane = float((self.__plane_normal.T @ camera_center)[0, 0])
        if self.__plane_distance is not None:
            dist_camera_to_plane -= self.__plane_distance

        if abs(dist_camera_to_plane) < 1.0:
            return False, f"Camera too close to plane: {dist_camera_to_plane:.2f}mm"

        return True, "Plane geometry is valid"

    def __repr__(self) -> str:
        """Cute representation showing the transformation state and matrices."""
        angles = f"üìê roll={self.roll:.1f}¬∞ tilt={self.pitch:.1f}¬∞ yaw={self.yaw:.1f}¬∞"

        # Pretty print the regular matrix with aligned columns
        matrix = self.H
        matrix_lines = []
        for row in matrix:
            formatted_row = "  ‚îÇ" + "  ".join(f"{val:7.3f}" for val in row) + "‚îÇ"
            matrix_lines.append(formatted_row)

        matrix_str = "\n".join([
            "  Matrix:",
            "  ‚îå" + " " * 25 + "‚îê",
            matrix_lines[0],
            matrix_lines[1],
            matrix_lines[2],
            "  ‚îî" + " " * 25 + "‚îò"
        ])

        # Pretty print the normalized matrix
        matrix_norm = self.normalized
        matrix_norm_lines = []
        for row in matrix_norm:
            formatted_row = "  ‚îÇ" + "  ".join(f"{val:7.4f}" for val in row) + "‚îÇ"
            matrix_norm_lines.append(formatted_row)

        matrix_norm_str = "\n".join([
            "  Matrix (normalized):",
            "  ‚îå" + " " * 25 + "‚îê",
            matrix_norm_lines[0],
            matrix_norm_lines[1],
            matrix_norm_lines[2],
            "  ‚îî" + " " * 25 + "‚îò"
        ])

        return (
            f"Homography2(\n"
            f"  {angles}\n"
            f"{matrix_str}\n"
            f"{matrix_norm_str}\n"
            f")"
        )
