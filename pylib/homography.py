# -*- coding: utf-8 -*-
"""projective_transform

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z_gBLaNOzpgvCkXWAUNcrujhLhR2j47H
"""

import numpy as np
import math

class Homography2():
    def __init__(self):
        self.width = 0
        self.height = 0
        self.pitch_r = 0.0
        self.tilt_r = 0.0
        self.rotation_r = 0.0
        self.x_matrix = np.identity(3, dtype=np.float32)
        self.y_matrix = np.identity(3, dtype=np.float32)
        self.z_matrix = np.identity(3, dtype=np.float32)
        self.r_matrix = np.identity(3, dtype=np.float32)                   # rotation matrix
        self.dist_cam = 0.0                                                # distance between camera and world plane
        self.dist_virtual = 0.0                                            # virtual distance to world plane
        self.t_vec = np.array([[0.0], [0.0], [0.0]], dtype=np.float32)     # translation vector
        self.vertical_scale = 1.0
        self.horizontal_scale = 1.0
        self._tilt_compensation = True
    
    def __set_translation(self):
        tx = self.dist_cam - self.dist_virtual
        tz = 0.0
        if self._tilt_compensation:
            # compensate for optical-axis shift due to pitch
            tz = -self.dist_cam * np.tan(self.pitch_r)

        self.t_vec = np.array([[tx], [0.0], [tz]])
    
    @property 
    def tilt_compensation(self):
        return self._tilt_compensation
    @tilt_compensation.setter
    def tilt_compensation(self, value):
        self._tilt_compensation = value
        self.__set_translation()

    @property
    def camera_distance(self):
        return self.dist_cam

    @camera_distance.setter
    def camera_distance(self, value):
        self.dist_cam = value
        self.__set_translation()
    
    @property
    def image_distance(self):
        return self.dist_virtual
    
    @image_distance.setter
    def image_distance(self, value):
        self.dist_virtual = value
        self.__set_translation()
        
    @property
    def pitch(self):
        return np.rad2deg(self.pitch_r)

    @pitch.setter
    def pitch(self, value):
        self.pitch_r = np.radians(value)
        self.x_matrix = np.array([
            [1,             0,              0],
            [0,  np.cos(self.pitch_r), -np.sin(self.pitch_r)],
            [0,  np.sin(self.pitch_r),  np.cos(self.pitch_r)]
        ], dtype=np.float32)
        self.__set_translation()

    @property
    def tilt(self):
        return np.rad2deg(self.tilt_r)

    @tilt.setter
    def tilt(self, value):
        self.tilt_r = np.radians(value)
        self.y_matrix = np.array([
            [ np.cos(self.tilt_r),  0, np.sin(self.tilt_r)],
            [ 0,              1,        0],
            [-np.sin(self.tilt_r),  0, np.cos(self.tilt_r)]
        ], dtype=np.float32)

    @property
    def rotation(self):
        return np.rad2deg(self.rotation_r)

    @rotation.setter
    def rotation(self, value):
        self.rotation_r = np.radians(value)
        self.z_matrix = np.array([
            [ np.cos(self.rotation_r), -np.sin(self.rotation_r), 0],
            [ np.sin(self.rotation_r),  np.cos(self.rotation_r), 0],
            [ 0,             0,            1]
        ], dtype=np.float32)

    @property 
    def matrix(self):
        self.r_matrix = self.z_matrix @ self.y_matrix @ self.x_matrix
        H = np.hstack((self.r_matrix[:, :2], self.t_vec))
        S = np.diag([self.horizontal_scale, self.vertical_scale, 1.0])
        H = S @ H
        H[1, :] *= self.vertical_scale
        # Make square 3x3
        H_np = np.eye(3)
        H_np[:3, :] = H
        return H_np

    @property
    def matrix_normalized(self):
        """
        Return normalized homography matrix (divided by bottom-right element).
        In homogeneous coordinates, matrices are equivalent up to scalar multiplication.
        Normalization ensures the [2,2] element is 1.0 for consistency.
        """
        # --- normalize ---
        matrix = self.matrix
        matrix /= matrix[2, 2]   # ensures bottom-right = 1 (usually redundant, but safe)
        matrix /= np.linalg.norm(matrix)    # optional: scale so that total magnitude â‰ˆ 1
        return matrix

class Homography():
    def __init__(self, img_width, img_height, pitch_angle_degrees=None, clockwise = None):
        self.orig_width = img_width
        self.orig_height = img_height

        if pitch_angle_degrees is None:
            pitch_angle_degrees = 0.0
        self.pitch = math.radians(pitch_angle_degrees)

        rotation_z_radians = math.pi/2  # radians
        if clockwise == False:
            rotation_z_radians = 3*math.pi/2  # radians

        self._width = 0
        self._height = 0
        self.corners_projected = np.array([])
        self.corners_original = np.array([])
        self.__matrix = np.array([])

        """
        Compute 3x3 homography matrix for perspective correction in texture space.
        needs to be applied before rotation!
        """
        resolution = (self.orig_width, self.orig_height)  # Use actual image resolution
        focal_length_mm = 2.95  # Focal length in mm

        cx = resolution[0] / 2.0  # Image center x
        cy = resolution[1] / 2.0  # Image center y

        cos_z = math.cos(rotation_z_radians)
        sin_z = math.sin(rotation_z_radians)


        rotation_matrix = np.array([
            [cos_z, -sin_z, cx - cos_z * cx + sin_z * cy],
            [sin_z,  cos_z, cy - sin_z * cx - cos_z * cy],
            [0.0,    0.0,   1.0]
        ])

        # Stage 2: Pitch correction (camera tilted upward)
        # When camera tilts upward, we need inverse perspective transformation
        # Key insight: bottom edge (y=height) should remain unchanged (ground plane at camera)
        # Top edge (y=0) should widen (far distance)
        # Pivot point is at BOTTOM center of image, not image center

        # Calculate focal length in pixels
        pixel_pitch_um = 1.45  # micrometers
        focal_length_px = (focal_length_mm * 1000.0) / pixel_pitch_um

        # Pitch correction homography
        # For upward tilt: bottom of image = near (unchanged), top of image = far (widens)
        cos_pitch = math.cos(self.pitch)
        sin_pitch = math.sin(self.pitch)

        # Perspective transformation for pitch around horizontal axis (x-axis rotation in image space)
        # This is the inverse perspective transformation
        pitch_matrix = np.array([
            [1.0,  0.0,                         0.0],
            [0.0,           cos_pitch,                -sin_pitch * focal_length_px],
            [0.0,           sin_pitch / focal_length_px, cos_pitch]
        ])

        # Calculate pivot point (where camera optical axis intersects the image plane)
        # pivot_x is always at horizontal center
        # pivot_y depends on pitch angle and focal length
        # When pitch = 0, pivot is at cy (image center)
        # When pitch = FOV_vertical/2, pivot is at img_height (bottom edge)
        # Formula: pivot_y = cy + focal_length_px * tan(pitch)

        pivot_x = cx
        tan_pitch = math.tan(self.pitch)
        pivot_y = cy + focal_length_px * tan_pitch

        translate_to_origin = np.array([
            [1.0, 0.0, -pivot_x],
            [0.0, 1.0, -pivot_y],
            [0.0, 0.0, 1.0]
        ])

        translate_back = np.array([
            [1.0, 0.0, pivot_x],
            [0.0, 1.0, pivot_y],
            [0.0, 0.0, 1.0]
        ])

        # Combine: translate to origin -> pitch correction -> translate back
        self.__matrix = translate_back @ pitch_matrix @ translate_to_origin

        # Order: pitch correction first, then rotation
        # This undoes the physical transformations in reverse order
        self.__matrix = rotation_matrix @ self.__matrix

    @property
    def matrix(self):
        return self.__matrix
    
    @property
    def matrix_glsl(self):
        # Convert row-major numpy matrix to column-major list for GLSL mat3
        return self.__matrix.T.flatten().tolist()

    @property
    def matrix_list(self):
        # Convert row-major numpy matrix to column-major list for GLSL mat3
        return self.__matrix.flatten().tolist()

    @property
    def matrix_normalized(self):
        """
        Return normalized homography matrix (divided by bottom-right element).
        In homogeneous coordinates, matrices are equivalent up to scalar multiplication.
        Normalization ensures the [2,2] element is 1.0 for consistency.
        """
        return self.__matrix / self.__matrix[2, 2]
    @property
    def matrix_normalized_glsl(self):
        """
        Return normalized homography matrix as column-major list for GLSL mat3.
        """
        normalized = self.__matrix / self.__matrix[2, 2]
        return normalized.T.flatten().tolist()


    def translate(self):
        tx = -self.bounding_box_cropped[0,0]
        ty = -self.bounding_box_cropped[0,1]
        translation_matrix = np.array([
            [1.0, 0.0, tx],
            [0.0, 1.0, ty],
            [0.0, 0.0, 1.0]
        ])
        self.__matrix = translation_matrix @ self.matrix

    @property
    def bounding_box_original(self):
        return np.array([[0, 0], [self.orig_width-1, 0], [self.orig_width-1, self.orig_height-1], [0, self.orig_height-1], [0, 0]])

    @property
    def bounding_box_projected(self):
        pts_h = np.hstack([self.bounding_box_original, np.ones((self.bounding_box_original.shape[0],1))])   # (N,3)
        warped = pts_h @ self.matrix.T                                       # (N,3)
        warped /= warped[:,2].reshape(-1,1)                        # divide by lambda
        return warped[:,:2]

    @property
    def bounding_box_cropped(self):
        bb = self.bounding_box_projected
        sy = np.sort(np.unique(bb[:, 1]))
        m = np.max(sy)
        sy = sy[sy != m]
        m = np.min(sy)
        sy = sy[sy != m]
        min_y = int(np.floor(min(sy)))
        max_y = int(np.floor(max(sy)))
        min_x = int(np.floor(bb[:, 0].min()))
        max_x = int(np.ceil(bb[:, 0].max()))
        self._width = max_x - min_x
        self._height = max_y - min_y
        return np.array([[min_x, min_y], [min_x, max_y], [max_x, max_y], [max_x, min_y], [min_x, min_y]])

    @property
    def dimensions_cropped(self):
        return (self._width, self._height)

