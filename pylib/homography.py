# -*- coding: utf-8 -*-
"""projective_transform

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z_gBLaNOzpgvCkXWAUNcrujhLhR2j47H
"""

import numpy as np
import math

class Homography():
    def __init__(self, img_width, img_height, pitch_angle_degrees=None, clockwise = None):
        self.orig_width = img_width
        self.orig_height = img_height

        if pitch_angle_degrees is None:
            pitch_angle_degrees = 0.0
        self.pitch = math.radians(pitch_angle_degrees)

        rotation_z_radians = math.pi/2  # radians
        if clockwise == False:
            rotation_z_radians = 3*math.pi/2  # radians

        self._width = 0
        self._height = 0
        self.corners_projected = np.array([])
        self.corners_original = np.array([])
        self.__matrix = np.array([])

        """
        Compute 3x3 homography matrix for perspective correction in texture space.
        needs to be applied before rotation!
        """
        resolution = (self.orig_width, self.orig_height)  # Use actual image resolution
        focal_length_mm = 2.95  # Focal length in mm

        cx = resolution[0] / 2.0  # Image center x
        cy = resolution[1] / 2.0  # Image center y

        cos_z = math.cos(rotation_z_radians)
        sin_z = math.sin(rotation_z_radians)


        rotation_matrix = np.array([
            [cos_z, -sin_z, cx - cos_z * cx + sin_z * cy],
            [sin_z,  cos_z, cy - sin_z * cx - cos_z * cy],
            [0.0,    0.0,   1.0]
        ])
        print(f"rotattion matrix: {rotation_matrix.shape}")

        # Stage 2: Pitch correction (camera tilted upward)
        # When camera tilts upward, we need inverse perspective transformation
        # Key insight: bottom edge (y=height) should remain unchanged (ground plane at camera)
        # Top edge (y=0) should widen (far distance)
        # Pivot point is at BOTTOM center of image, not image center

        # Calculate focal length in pixels
        pixel_pitch_um = 1.45  # micrometers
        focal_length_px = (focal_length_mm * 1000.0) / pixel_pitch_um

        # Pitch correction homography
        # For upward tilt: bottom of image = near (unchanged), top of image = far (widens)
        cos_pitch = math.cos(self.pitch)
        sin_pitch = math.sin(self.pitch)

        # Perspective transformation for pitch around horizontal axis (x-axis rotation in image space)
        # This is the inverse perspective transformation
        pitch_matrix = np.array([
            [1.0,  0.0,                         0.0],
            [0.0,           cos_pitch,                -sin_pitch * focal_length_px],
            [0.0,           sin_pitch / focal_length_px, cos_pitch]
        ])

        # Calculate pivot point (where camera optical axis intersects the image plane)
        # pivot_x is always at horizontal center
        # pivot_y depends on pitch angle and focal length
        # When pitch = 0, pivot is at cy (image center)
        # When pitch = FOV_vertical/2, pivot is at img_height (bottom edge)
        # Formula: pivot_y = cy + focal_length_px * tan(pitch)

        pivot_x = cx
        tan_pitch = math.tan(self.pitch)
        pivot_y = cy + focal_length_px * tan_pitch

        translate_to_origin = np.array([
            [1.0, 0.0, -pivot_x],
            [0.0, 1.0, -pivot_y],
            [0.0, 0.0, 1.0]
        ])

        translate_back = np.array([
            [1.0, 0.0, pivot_x],
            [0.0, 1.0, pivot_y],
            [0.0, 0.0, 1.0]
        ])

        # Combine: translate to origin -> pitch correction -> translate back
        self.__matrix = translate_back @ pitch_matrix @ translate_to_origin

        # Order: pitch correction first, then rotation
        # This undoes the physical transformations in reverse order
        self.__matrix = rotation_matrix @ self.__matrix
        self.__matrix = rotation_matrix

    @property
    def matrix(self):
        return self.__matrix
    
    @property
    def matrix_glsl(self):
        # Convert row-major numpy matrix to column-major list for GLSL mat3
        return self.__matrix.T.flatten().tolist()

    @property
    def matrix_list(self):
        # Convert row-major numpy matrix to column-major list for GLSL mat3
        return self.__matrix.flatten().tolist()

    @property
    def matrix_normalized(self):
        """
        Return normalized homography matrix (divided by bottom-right element).
        In homogeneous coordinates, matrices are equivalent up to scalar multiplication.
        Normalization ensures the [2,2] element is 1.0 for consistency.
        """
        return self.__matrix / self.__matrix[2, 2]
    @property
    def matrix_normalized_glsl(self):
        """
        Return normalized homography matrix as column-major list for GLSL mat3.
        """
        normalized = self.__matrix / self.__matrix[2, 2]
        return normalized.T.flatten().tolist()


    def translate(self):
        tx = -self.bounding_box_cropped[0,0]
        ty = -self.bounding_box_cropped[0,1]
        translation_matrix = np.array([
            [1.0, 0.0, tx],
            [0.0, 1.0, ty],
            [0.0, 0.0, 1.0]
        ])
        self.__matrix = translation_matrix @ self.matrix

    @property
    def bounding_box_original(self):
        return np.array([[0, 0], [self.orig_width-1, 0], [self.orig_width-1, self.orig_height-1], [0, self.orig_height-1], [0, 0]])

    @property
    def bounding_box_projected(self):
        pts_h = np.hstack([self.bounding_box_original, np.ones((self.bounding_box_original.shape[0],1))])   # (N,3)
        warped = pts_h @ self.matrix.T                                       # (N,3)
        warped /= warped[:,2].reshape(-1,1)                        # divide by lambda
        return warped[:,:2]

    @property
    def bounding_box_cropped(self):
        bb = self.bounding_box_projected
        sy = np.sort(np.unique(bb[:, 1]))
        m = np.max(sy)
        sy = sy[sy != m]
        m = np.min(sy)
        sy = sy[sy != m]
        min_y = int(np.floor(min(sy)))
        max_y = int(np.floor(max(sy)))
        min_x = int(np.floor(bb[:, 0].min()))
        max_x = int(np.ceil(bb[:, 0].max()))
        self._width = max_x - min_x
        self._height = max_y - min_y
        return np.array([[min_x, min_y], [min_x, max_y], [max_x, max_y], [max_x, min_y], [min_x, min_y]])

    @property
    def dimensions_cropped(self):
        return (self._width, self._height)

