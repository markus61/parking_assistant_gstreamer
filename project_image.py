# -*- coding: utf-8 -*-
"""projective_transform

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z_gBLaNOzpgvCkXWAUNcrujhLhR2j47H
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import cv2
import math

def homography_matrix(img_width, img_height):
    """
    Compute 3x3 homography matrix for perspective correction in texture space.
    needs to be applied before rotation!
    """
    distance_to_object_plane = 4 # meters
    resolution = (img_width, img_height)  # Use actual image resolution
    rotation_z_degrees = 270.0  # degrees
    pitch_angle_degrees = 32.5  # degrees
    tilt_angle = 0.0  # degrees
    focal_length_mm = 2.95  # Focal length in mm

    d = distance_to_object_plane * 1000  # Convert to mm
    cx = resolution[0] / 2.0  # Image center x
    cy = resolution[1] / 2.0  # Image center y
    alpha = math.radians(tilt_angle)
    efl_px = 1000 * focal_length_mm / 1.45
    cos_alpha = math.cos(alpha)


    tan_alpha = math.tan(alpha)
    one_one = efl_px / (d * cos_alpha)
    one_two = cx * tan_alpha / d
    two_two = efl_px / d + cy * tan_alpha / d
    two_three = cy - efl_px * tan_alpha
    three_two = tan_alpha / d

    # prepare the rotaion
    rotation_z_radians = math.radians(rotation_z_degrees)
    pitch_radians = math.radians(pitch_angle_degrees)
    cx = img_width / 2.0   # Image center x
    cy = img_height / 2.0  # Image center y
    cos_z = math.cos(rotation_z_radians)
    sin_z = math.sin(rotation_z_radians)


    rotation_matrix = np.array([
        [cos_z, -sin_z, cx - cos_z * cx + sin_z * cy],
        [sin_z,  cos_z, cy - sin_z * cx - cos_z * cy],
        [0.0,    0.0,   1.0]
    ])

    # Stage 2: Pitch correction (camera tilted upward)
    # When camera tilts upward, we need inverse perspective transformation
    # Key insight: bottom edge (y=height) should remain unchanged (ground plane at camera)
    # Top edge (y=0) should widen (far distance)
    # Pivot point is at BOTTOM center of image, not image center

    # Calculate focal length in pixels
    pixel_pitch_um = 1.45  # micrometers
    focal_length_px = (focal_length_mm * 1000.0) / pixel_pitch_um

    # Pitch correction homography
    # For upward tilt: bottom of image = near (unchanged), top of image = far (widens)
    cos_pitch = math.cos(pitch_radians)
    sin_pitch = math.sin(pitch_radians)

    # Perspective transformation for pitch around horizontal axis (x-axis rotation in image space)
    # This is the inverse perspective transformation
    pitch_matrix = np.array([
        [1.0,  0.0,                         0.0],
        [0.0,           cos_pitch,                -sin_pitch * focal_length_px],
        [0.0,           sin_pitch / focal_length_px, cos_pitch]
    ])

    # Translate to apply rotation around BOTTOM CENTER of image (not center)
    # Bottom edge is at y = img_height
    pivot_x = cx
    pivot_y = img_height  # Bottom of image

    translate_to_origin = np.array([
        [1.0, 0.0, -pivot_x],
        [0.0, 1.0, -pivot_y],
        [0.0, 0.0, 1.0]
    ])

    translate_back = np.array([
        [1.0, 0.0, pivot_x],
        [0.0, 1.0, pivot_y],
        [0.0, 0.0, 1.0]
    ])

    # Combine: translate to origin -> pitch correction -> translate back
    pitch_transform = translate_back @ pitch_matrix @ translate_to_origin

    # Stage 3: Combine rotation and pitch
    # Order: pitch correction first, then rotation
    # This undoes the physical transformations in reverse order
    combined_transform = rotation_matrix @ pitch_transform

    return combined_transform


def apply_homography(points, H):
    """
    Apply projective transformation (homography).
    points: (N,2) array of xy coords
    H: 3x3 homography matrix
    """
    pts_h = np.hstack([points, np.ones((points.shape[0],1))])   # (N,3)
    warped = pts_h @ H.T                                       # (N,3)
    warped /= warped[:,2].reshape(-1,1)                        # divide by lambda
    return warped[:,:2]


# --- load an image ---
sample = mpimg.imread('camera.jpg')
#monopoly = cv2.cvtColor(monopoly, cv2.COLOR_BGR2RGB)

# Get image dimensions
height, width = sample.shape[:2]
print(f"Image dimensions: {width}x{height}")

# --- Example projective matrix (warp into trapezoid) ---
# Note: You may want to scale this homography based on image dimensions
# H = np.array([[1, 0.2, 0],
#               [0.1, 1, 0],
#              [0.001, 0.001, 1]])

H = homography_matrix(width, height)


# Method 2: Manual approach using apply_homography (for educational purposes)
# Create grid of all pixel coordinates in the image
y_coords, x_coords = np.mgrid[0:height, 0:width]
pixel_coords = np.column_stack([x_coords.ravel(), y_coords.ravel()])  # (N, 2)

# Apply homography to all pixel coordinates
#projected_coords = apply_homography(pixel_coords, H)

# Get corner points for visualization
corners_original = np.array([[0, 0], [width-1, 0], [width-1, height-1], [0, height-1], [0, 0]])
corners_projected = apply_homography(corners_original, H)

# Calculate bounding box of transformed image
min_x = int(np.floor(corners_projected[:, 0].min()))
max_x = int(np.ceil(corners_projected[:, 0].max()))
min_y = int(np.floor(corners_projected[:, 1].min()))
max_y = int(np.ceil(corners_projected[:, 1].max()))

print(f"Projected bounds: x=[{min_x}, {max_x}], y=[{min_y}, {max_y}]")
print(f"Corner 0 (top-left): {corners_projected[0]}")
print(f"Corner 1 (top-right): {corners_projected[1]}")
print(f"Corner 2 (bottom-right): {corners_projected[2]}")
print(f"Corner 3 (bottom-left): {corners_projected[3]}")

# Calculate all four edge lengths to find which is the "near" edge (unchanged by perspective)
edge_01_len = np.sqrt((corners_projected[1][0] - corners_projected[0][0])**2 +
                      (corners_projected[1][1] - corners_projected[0][1])**2)
edge_12_len = np.sqrt((corners_projected[2][0] - corners_projected[1][0])**2 +
                      (corners_projected[2][1] - corners_projected[1][1])**2)
edge_23_len = np.sqrt((corners_projected[3][0] - corners_projected[2][0])**2 +
                      (corners_projected[3][1] - corners_projected[2][1])**2)
edge_30_len = np.sqrt((corners_projected[0][0] - corners_projected[3][0])**2 +
                      (corners_projected[0][1] - corners_projected[3][1])**2)

print(f"Edge 0-1 length: {edge_01_len}")
print(f"Edge 1-2 length: {edge_12_len}")
print(f"Edge 2-3 length: {edge_23_len}")
print(f"Edge 3-0 length: {edge_30_len}")

# The trapezoid should have two parallel edges with different lengths
# The shorter edge is the "near" edge (unchanged by perspective)
# Find the shortest edge - that's our reference for cropping
edges = [(0, 1, edge_01_len), (1, 2, edge_12_len), (2, 3, edge_23_len), (3, 0, edge_30_len)]
shortest_edge = min(edges, key=lambda x: x[2])
print(f"Shortest edge: {shortest_edge[0]}-{shortest_edge[1]} with length {shortest_edge[2]}")

# Use the shortest edge to determine output width
# The shortest edge defines the narrowest part - use that as output width
near_edge_width = int(np.ceil(shortest_edge[2]))

# Adjust homography to shift everything into visible canvas
translation_matrix = np.array([[1, 0, -min_x],
                                [0, 1, -min_y],
                                [0, 0, 1]])
H_adjusted = translation_matrix @ H

# Calculate output dimensions - use the near edge width to crop black triangles
output_width = near_edge_width
output_height = max_y - min_y

# --- Plot ---
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Original image
axes[0].imshow(sample)
axes[0].set_title("Original Camera Image")
axes[0].axis('off')


# Method 1: Using cv2.warpPerspective (recommended - faster and handles interpolation)
warped_image = cv2.warpPerspective(sample, H_adjusted, (output_width, output_height))

# Warped image using cv2.warpPerspective
axes[1].imshow(warped_image)
axes[1].set_title("Warped Image (Homography Applied)")
axes[1].axis('off')

# Overlay showing transformation of corner points
axes[2].imshow(sample, alpha=0.5)
axes[2].plot(corners_original[:, 0], corners_original[:, 1], 'b-', linewidth=2, label="Original corners")
axes[2].plot(corners_projected[:, 0], corners_projected[:, 1], 'r-', linewidth=2, label="Projected corners")
axes[2].set_title("Corner Transformation Overlay")
axes[2].legend()
axes[2].axis('off')

plt.tight_layout()
plt.show()
